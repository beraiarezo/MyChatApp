
/**
 *
 *  RestfulNewtableCtrlBase.cc
 *  DO NOT EDIT. This file is generated by drogon_ctl automatically.
 *  Users should implement business logic in the derived class.
 */

#include "RestfulNewtableCtrlBase.h"
#include <string>


void RestfulNewtableCtrlBase::get(const HttpRequestPtr &req,
                                  std::function<void(const HttpResponsePtr &)> &&callback)
{
     Json::Value ret;
    ret["result"]="ok";
    ret["user_name"]="Jack";
    ret["user_id"]='1';
    ret["gender"]=1;
     auto resp=HttpResponse::newHttpJsonResponse(ret);
    callback(resp);
    // auto dbClientPtr = getDbClient();
    // drogon::orm::Mapper<Newtable> mapper(dbClientPtr);
    // auto &parameters = req->parameters();
    // auto iter = parameters.find("sort");
    // if(iter != parameters.end())
    // {
    //     auto sortFields = drogon::utils::splitString(iter->second, ",");
    //     for(auto &field : sortFields)
    //     {
    //         if(field.empty())
    //             continue;
    //         if(field[0] == '+')
    //         {
    //             field = field.substr(1);
    //             mapper.orderBy(field, SortOrder::ASC);
    //         }
    //         else if(field[0] == '-')
    //         {
    //             field = field.substr(1);
    //             mapper.orderBy(field, SortOrder::DESC);
    //         }
    //         else
    //         {
    //             mapper.orderBy(field, SortOrder::ASC);
    //         }
    //     }
    // }
    // iter = parameters.find("offset");
    // if(iter != parameters.end())
    // {
    //     try{
    //         auto offset = std::stoll(iter->second);
    //         mapper.offset(offset);
    //     }
    //     catch(...)
    //     {
    //         auto resp = HttpResponse::newHttpResponse();
    //         resp->setStatusCode(k400BadRequest);
    //         callback(resp);
    //         return;
    //     }
    // }
    // iter = parameters.find("limit");
    // if(iter != parameters.end())
    // {
    //     try{
    //         auto limit = std::stoll(iter->second);
    //         mapper.limit(limit);
    //     }
    //     catch(...)
    //     {
    //         auto resp = HttpResponse::newHttpResponse();
    //         resp->setStatusCode(k400BadRequest);
    //         callback(resp);
    //         return;
    //     }
    // }    
    // auto callbackPtr =
    //     std::make_shared<std::function<void(const HttpResponsePtr &)>>(
    //         std::move(callback));
    // auto jsonPtr = req->jsonObject();
    // if(jsonPtr && jsonPtr->isMember("filter"))
    // {
    //     try{
    //         auto criteria = makeCriteria((*jsonPtr)["filter"]);
    //         mapper.findBy(criteria,
    //             [req, callbackPtr, this](const std::vector<Newtable> &v) {
    //                 Json::Value ret;
    //                 ret.resize(0);
    //                 for (auto &obj : v)
    //                 {
    //                     ret.append(makeJson(req, obj));
    //                 }
    //                 (*callbackPtr)(HttpResponse::newHttpJsonResponse(ret));
    //             },
    //             [callbackPtr](const DrogonDbException &e) { 
    //                 LOG_ERROR << e.base().what();
    //                 Json::Value ret;
    //                 ret["error"] = "database error";
    //                 auto resp = HttpResponse::newHttpJsonResponse(ret);
    //                 resp->setStatusCode(k500InternalServerError);
    //                 (*callbackPtr)(resp);    
    //             });
    //     }
    //     catch(const std::exception &e)
    //     {
    //         LOG_ERROR << e.what();
    //         Json::Value ret;
    //         ret["error"] = e.what();
    //         auto resp = HttpResponse::newHttpJsonResponse(ret);
    //         resp->setStatusCode(k400BadRequest);
    //         (*callbackPtr)(resp);
    //         return;    
    //     }
    // }
    // else
    // {
    //     mapper.findAll([req, callbackPtr, this](const std::vector<Newtable> &v) {
    //             Json::Value ret;
    //             ret.resize(0);
    //             for (auto &obj : v)
    //             {
    //                 ret.append(makeJson(req, obj));
    //             }
    //             (*callbackPtr)(HttpResponse::newHttpJsonResponse(ret));
    //         },
    //         [callbackPtr](const DrogonDbException &e) { 
    //             LOG_ERROR << e.base().what();
    //             Json::Value ret;
    //             ret["error"] = "database error";
    //             auto resp = HttpResponse::newHttpJsonResponse(ret);
    //             resp->setStatusCode(k500InternalServerError);
    //             (*callbackPtr)(resp);    
    //         });
    // }


}

void RestfulNewtableCtrlBase::create(const HttpRequestPtr &req,
                                     std::function<void(const HttpResponsePtr &)> &&callback)
{
    LOG_DEBUG << "Create new Newtable";
    auto jsonPtr = req->jsonObject();
    
    if(!jsonPtr)
    {
        Json::Value ret;
        ret["error"]="No json object is found in the request";
        auto resp= HttpResponse::newHttpJsonResponse(ret);
        resp->setStatusCode(k400BadRequest);
        callback(resp);
        return;
    }
    std::string err;
    if(!doCustomValidations(*jsonPtr, err))
    {
        Json::Value ret;
        ret["error"] = err;
        auto resp= HttpResponse::newHttpJsonResponse(ret);
        resp->setStatusCode(k400BadRequest);
        callback(resp);
        return;
    }
    if(isMasquerading())
    {
        if(!Newtable::validateMasqueradedJsonForCreation(*jsonPtr, masqueradingVector(), err))
        {
            Json::Value ret;
            ret["error"] = err;
            auto resp= HttpResponse::newHttpJsonResponse(ret);
            resp->setStatusCode(k400BadRequest);
            callback(resp);
            return;
        }
    }
    else
    {
        if(!Newtable::validateJsonForCreation(*jsonPtr, err))
        {
            Json::Value ret;
            ret["error"] = err;
            auto resp= HttpResponse::newHttpJsonResponse(ret);
            resp->setStatusCode(k400BadRequest);
            callback(resp);
            return;
        }
    }
    try
    {
        Newtable object =
            (isMasquerading() ?
             Newtable(*jsonPtr, masqueradingVector()) :
             Newtable(*jsonPtr));
        auto dbClientPtr = getDbClient();
           LOG_DEBUG << dbClientPtr.get() << " ---- ------ ----";

        auto callbackPtr =
            std::make_shared<std::function<void(const HttpResponsePtr &)>>(
                std::move(callback));
        drogon::orm::Mapper<Newtable> mapper(dbClientPtr);
        mapper.insert(
            object,
            [req, callbackPtr, this](Newtable newObject){
                (*callbackPtr)(HttpResponse::newHttpJsonResponse(
                    makeJson(req, newObject)));
            },
            [callbackPtr](const DrogonDbException &e){
                LOG_ERROR << e.base().what();
                Json::Value ret;
                ret["error"] = "database error";
                auto resp = HttpResponse::newHttpJsonResponse(ret);
                resp->setStatusCode(k500InternalServerError);
                (*callbackPtr)(resp);
            });
    }
    catch(const Json::Exception &e)
    {
        LOG_ERROR << e.what();
        Json::Value ret;
        ret["error"]="Field type error";
        auto resp= HttpResponse::newHttpJsonResponse(ret);
        resp->setStatusCode(k400BadRequest);
        callback(resp);
        return;
    }
}

/*
void RestfulNewtableCtrlBase::update(const HttpRequestPtr &req,
                                     std::function<void(const HttpResponsePtr &)> &&callback)
{

}*/

RestfulNewtableCtrlBase::RestfulNewtableCtrlBase()
    : RestfulController({
          "column1",
          "column2",
          "column3"
      })
{
   /**
    * The items in the vector are aliases of column names in the table.
    * if one item is set to an empty string, the related column is not sent
    * to clients.
    */
    enableMasquerading({
        "column1", // the alias for the column1 column.
        "column2", // the alias for the column2 column.
        "column3"  // the alias for the column3 column.
    });
}
